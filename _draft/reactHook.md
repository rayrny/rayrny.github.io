### useRef

컴포넌트에서 특정 DOM 을 선택해야 할 때, `ref` 를 사용해야 한다고 배웠다. 그리고, 함수형 컴포넌트에서 이를 설정 할 때 `useRef` 를 사용한다.
`useRef` 는 DOM 을 선택하는 용도 외에, 컴포넌트 안에서 조회 및 수정 할 수 있는 변수를 관리할 수 있다.
`useRef` 로 관리하는 변수는 값이 바뀐다고 해서 컴포넌트가 리렌더링되지 않는다. 리액트 컴포넌트에서의 상태는 상태를 바꾸는 함수를 호출하고 나서 그 다음 렌더링 이후로 업데이트 된 상태를 조회 할 수 있는 반면, `useRef` 로 관리하고 있는 변수는 설정 후 바로 조회 할 수 있다.

컴포넌트 참조 오류가 발생했을 경우

<aside>
⚠️ `Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?`

</aside>

위의 에러는 DOM 객체에 접근할 수 없는 경우 발생한다(함수형 컴포넌트 그 자체일 때?). 해결 방법은 안에 div 박스를 하나 더 만들어서 참조할 수 있도록 하면 된다.

### useMemo

`useMemo` 의 첫번째 파라미터에는 어떻게 연산할지 정의하는 함수를 넣어주면 되고 두번째 파라미터에는 deps 배열([] ← 요거)을 넣어주면 되는데, 이 배열 안에 넣은 내용이 바뀌면, 등록한 함수를 호출해서 값을 연산해주고, 만약에 내용이 바뀌지 않았다면 이전에 연산한 값을 재사용한다.

useMemo는 메모이즈된 값을 return하는 **hook**이다.

### useCallback

`useMemo` 는 특정 결과값을 재사용 할 때 사용하는 반면, `useCallback` 은 특정 함수를 새로 만들지 않고 재사용하고 싶을때 사용한다.

`useCallback(fn, deps)`은 `useMemo(() => fn, deps)`와 같다.

함수는 컴포넌트가 리렌더링 될 때마다 새로 만들어지는데, 최적화를 위해서는 함수 재사용이 필수적이다.

주의 할 점은, 함수 안에서 사용하는 상태 혹은 props 가 있다면 꼭, `deps` 배열안에 포함시켜야 한다. 만약 `deps` 배열 안에 함수에서 사용하는 값을 넣지 않게 되면, 함수 내에서 해당 값들을 참조할때 가장 최신 값을 참조 할 것이라고 보장 할 수 없다. props 로 받아온 함수가 있다면, 이 또한 `deps` 에 넣어줘야 한다.

### React.memo

→ **Higher-Order Components(HOC)**이다. (컴포넌트를 인자로 받아 새로운 컴포넌트롤 다시 return해주는 함수) HOC는 리액트의 API가 아니라 리액트가 컴포넌트를 구성하는데 있어서의 일종의 패턴이라고 보면된다.

이를 사용하면 컴포넌트의 props가 바뀌지 않았을 때 리렌더링을 방지한다. 이를 통해 리렌더링이 필요한 상황에서만 리렌더링을 할 수 있다.

다른 말로 하면,

React는 먼저 컴포넌트를 렌더링(rendering) 한 뒤, 이전 렌더된 결과와 비교하여 DOM 업데이트를 결정한다. 만약 렌더 결과가 이전과 다르다면, React는 DOM을 업데이트한다.

컴포넌트가 `React.memo()`로 래핑 될 때, React는 컴포넌트를 렌더링하고 결과를 메모이징(Memoizing)한다. 그리고 다음 렌더링이 일어날 때 `props`가 같다면, React는 메모이징(Memoizing)된 내용을 재사용한다.

React.memo는 오직 props가 변경됐는지 아닌지만 체크한다. 만약 React.memo에 감싸진 함수형 컴포넌트가 함수 내부에서 useState나 useContext같은 훅을 사용하고 있다면, state나 context가 변경될 때마다 리렌더링된다.

같은 props로 렌더링이 자주 일어나는 경우, 예를 들어 영화 정보를 1초마다 업데이트 하는 경우에 일치하지 않는다면 `React.memo()`를 사용할 필요가 없을 가능성이 높다.

경험적으로, 성능적인 이점을 얻지 못한다면 메모이제이션을 사용하지 않는것이 좋다.

> 성능 관련 변경이 잘못 적용 된다면 성능이 오히려 악화될 수 있다. React.memo()를 현명하게 사용하라.
> 

다만, 콜백 함수를 prop으로 사용하는 컴퍼넌트에서 메모이징을 할 때 주의하라. 그리고 같은 렌더링을 할 때 이전과 동일한 콜백 함수 인스턴스를 넘기는지 확실히 하라.

### React.Fragment

`<> </>`로 간단하게 사용할 수 있지만, ~~만약 fragment 태그에 key를 직접 줘야 할 경우 `<React.Fragment key={}> </React.Fragment>`와 같이 명시한다.~~?????? 확인 필요

### React.forwardRef

### 함수형 업데이트

```jsx
setA(prevA → prevA + 1);
```

### useLayoutEffect

useEffect와 동일한 기능을 하지만, 모든 DOM 변경 후에 동기적으로 발생한다. 따라서 DOM의 레이아웃만을 리렌더링 할 경우에 사용한다. `useLayoutEffect` 의 내부에서 갱신은 브라우저가 화면을 그리기 이전에 동기적으로 수행된다. (useEffect로 해결이 안 될 경우에만 사용하는 것을 권장.)

→ 렌더링 최적화를 위한 작업을 할 때, 레이아웃만 건드는 경우에 사용했던 것 같다.
